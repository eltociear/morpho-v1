diff -ruN common/rewards-distribution/dependencies/MerkleProof.sol common/rewards-distribution/dependencies/MerkleProof.sol
--- common/rewards-distribution/dependencies/MerkleProof.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/MerkleProof.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: MIT
+// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)
+
+pragma solidity ^0.8.0;
+
+/**
+ * @dev These functions deal with verification of Merkle Trees proofs.
+ *
+ * The proofs can be generated using the JavaScript library
+ * https://github.com/miguelmota/merkletreejs[merkletreejs].
+ * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
+ *
+ * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
+ */
+library MerkleProof {
+    /**
+     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
+     * defined by `root`. For this, a `proof` must be provided, containing
+     * sibling hashes on the branch from the leaf to the root of the tree. Each
+     * pair of leaves and each pair of pre-images are assumed to be sorted.
+     */
+    function verify(
+        bytes32[] memory proof,
+        bytes32 root,
+        bytes32 leaf
+    ) internal pure returns (bool) {
+        return processProof(proof, leaf) == root;
+    }
+
+    /**
+     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up
+     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
+     * hash matches the root of the tree. When processing the proof, the pairs
+     * of leafs & pre-images are assumed to be sorted.
+     *
+     * _Available since v4.4._
+     */
+    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
+        bytes32 computedHash = leaf;
+        for (uint256 i = 0; i < proof.length; i++) {
+            bytes32 proofElement = proof[i];
+            if (computedHash <= proofElement) {
+                // Hash(current computed hash + current element of the proof)
+                computedHash = _efficientHash(computedHash, proofElement);
+            } else {
+                // Hash(current element of the proof + current computed hash)
+                computedHash = _efficientHash(proofElement, computedHash);
+            }
+        }
+        return computedHash;
+    }
+
+    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
+        assembly {
+            mstore(0x00, a)
+            mstore(0x20, b)
+            value := keccak256(0x00, 0x40)
+        }
+    }
+}
diff -ruN common/rewards-distribution/dependencies/MorphoToken.sol common/rewards-distribution/dependencies/MorphoToken.sol
--- common/rewards-distribution/dependencies/MorphoToken.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/MorphoToken.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "@rari-capital/solmate/src/tokens/ERC20.sol";
+
+contract MorphoToken is ERC20 {
+    constructor() ERC20("Morpho Token", "MORPHO", 18) {}
+}
diff -ruN common/rewards-distribution/dependencies/SafeTransferLib.sol common/rewards-distribution/dependencies/SafeTransferLib.sol
--- common/rewards-distribution/dependencies/SafeTransferLib.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/dependencies/SafeTransferLib.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: AGPL-3.0-only
+pragma solidity >=0.8.0;
+
+import {ERC20} from "@rari-capital/solmate/src/tokens/ERC20.sol";
+
+/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
+/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)
+/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.
+/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.
+library SafeTransferLib {
+    /*//////////////////////////////////////////////////////////////
+                             ETH OPERATIONS
+    //////////////////////////////////////////////////////////////*/
+
+    function safeTransferETH(address to, uint256 amount) internal {
+        bool success;
+
+        assembly {
+            // Transfer the ETH and store if it succeeded or not.
+            success := call(gas(), to, amount, 0, 0, 0, 0)
+        }
+
+        require(success, "ETH_TRANSFER_FAILED");
+    }
+
+    /*//////////////////////////////////////////////////////////////
+                            ERC20 OPERATIONS
+    //////////////////////////////////////////////////////////////*/
+
+    function safeTransferFrom(
+        ERC20 token,
+        address from,
+        address to,
+        uint256 amount
+    ) internal {
+        bool success = token.transferFrom(from, to, amount);
+
+        require(success, "TRANSFER_FROM_FAILED");
+    }
+
+    function safeTransfer(
+        ERC20 token,
+        address to,
+        uint256 amount
+    ) internal {
+        bool success = token.transfer(to, amount);
+
+        require(success, "TRANSFER_FAILED");
+    }
+
+    function safeApprove(
+        ERC20 token,
+        address to,
+        uint256 amount
+    ) internal {
+        bool success = token.approve(to, amount);
+
+        require(success, "APPROVE_FAILED");
+    }
+}
diff -ruN common/rewards-distribution/MerkleTree1.sol common/rewards-distribution/MerkleTree1.sol
--- common/rewards-distribution/MerkleTree1.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree1.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeMock.sol";
+
+contract MerkleTree1 is MerkleTreeMock {}
diff -ruN common/rewards-distribution/MerkleTree2.sol common/rewards-distribution/MerkleTree2.sol
--- common/rewards-distribution/MerkleTree2.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTree2.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeMock.sol";
+
+contract MerkleTree2 is MerkleTreeMock {}
diff -ruN common/rewards-distribution/MerkleTreeLib.sol common/rewards-distribution/MerkleTreeLib.sol
--- common/rewards-distribution/MerkleTreeLib.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTreeLib.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+library MerkleTreeLib {
+    struct Node {
+        bool created;
+        address left;
+        address right;
+        uint256 value;
+        bytes32 hashNode;
+    }
+
+    struct Tree {
+        mapping(address => Node) nodes;
+        address root;
+    }
+
+    function newAccount(
+        Tree storage tree,
+        address addr,
+        uint256 value
+    ) public {
+        Node storage node = tree.nodes[addr];
+        require(addr != address(0));
+        require(!node.created);
+        require(value != 0);
+
+        node.created = true;
+        node.value = value;
+        node.hashNode = keccak256(abi.encodePacked(addr, value));
+    }
+
+    function newNode(
+        Tree storage tree,
+        address parent,
+        address left,
+        address right
+    ) public {
+        Node storage parentNode = tree.nodes[parent];
+        Node storage leftNode = tree.nodes[left];
+        Node storage rightNode = tree.nodes[right];
+        require(parent != address(0));
+        require(!parentNode.created);
+        require(leftNode.created && rightNode.created);
+        require(leftNode.hashNode <= rightNode.hashNode);
+
+        parentNode.created = true;
+        parentNode.left = left;
+        parentNode.right = right;
+        parentNode.hashNode = keccak256(abi.encode(leftNode.hashNode, rightNode.hashNode));
+    }
+
+    function setRoot(Tree storage tree, address addr) public {
+        require(tree.nodes[addr].created);
+        tree.root = addr;
+    }
+
+    function isWellFormed(Tree storage tree, address addr) public view returns (bool) {
+        Node storage node = tree.nodes[addr];
+
+        if (!node.created) return true;
+
+        if (node.left == address(0) && node.right == address(0))
+            return
+                node.value != 0 && node.hashNode == keccak256(abi.encodePacked(addr, node.value));
+        else {
+            // Well-formed tree.nodes have exactly 0 or 2 children.
+            if (node.left == address(0) || node.right == address(0)) return false;
+            Node storage left = tree.nodes[node.left];
+            Node storage right = tree.nodes[node.right];
+            return
+                left.created &&
+                right.created &&
+                node.value == 0 &&
+                left.hashNode <= right.hashNode && // Well-formed tree.nodes should be pair sorted.
+                node.hashNode == keccak256(abi.encode(left.hashNode, right.hashNode));
+        }
+    }
+
+    function findProof(Tree storage, address) public pure returns (bytes32[] memory) {
+        return new bytes32[](0); // TODO
+    }
+
+    function getRoot(Tree storage tree) public view returns (address) {
+        return tree.root;
+    }
+
+    function getCreated(Tree storage tree, address addr) public view returns (bool) {
+        return tree.nodes[addr].created;
+    }
+
+    function getLeft(Tree storage tree, address addr) public view returns (address) {
+        return tree.nodes[addr].left;
+    }
+
+    function getRight(Tree storage tree, address addr) public view returns (address) {
+        return tree.nodes[addr].right;
+    }
+
+    function getValue(Tree storage tree, address addr) public view returns (uint256) {
+        return tree.nodes[addr].value;
+    }
+
+    function getHash(Tree storage tree, address addr) public view returns (bytes32) {
+        return tree.nodes[addr].hashNode;
+    }
+}
diff -ruN common/rewards-distribution/MerkleTreeMock.sol common/rewards-distribution/MerkleTreeMock.sol
--- common/rewards-distribution/MerkleTreeMock.sol	1970-01-01 01:00:00.000000000 +0100
+++ common/rewards-distribution/MerkleTreeMock.sol	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: GNU AGPLv3
+pragma solidity ^0.8.0;
+
+import "./MerkleTreeLib.sol";
+
+contract MerkleTreeMock {
+    using MerkleTreeLib for MerkleTreeLib.Tree;
+
+    MerkleTreeLib.Tree tree;
+
+    bool public initialized;
+
+    constructor() {
+        require(initialized == false);
+        initialized = true;
+    }
+
+    function newAccount(address addr, uint256 value) public {
+        tree.newAccount(addr, value);
+    }
+
+    function newNode(
+        address parent,
+        address left,
+        address right
+    ) public {
+        tree.newNode(parent, left, right);
+    }
+
+    function setRoot(address addr) public {
+        tree.setRoot(addr);
+    }
+
+    function isWellFormed(address addr) public view returns (bool) {
+        return tree.isWellFormed(addr);
+    }
+
+    function findProof(address addr) public view returns (bytes32[] memory) {
+        return tree.findProof(addr);
+    }
+
+    function getRoot() public view returns (address) {
+        return tree.getRoot();
+    }
+
+    function getCreated(address addr) public view returns (bool) {
+        return tree.getCreated(addr);
+    }
+
+    function getLeft(address addr) public view returns (address) {
+        return tree.getLeft(addr);
+    }
+
+    function getRight(address addr) public view returns (address) {
+        return tree.getRight(addr);
+    }
+
+    function getValue(address addr) public view returns (uint256) {
+        return tree.getValue(addr);
+    }
+
+    function getHash(address addr) public view returns (bytes32) {
+        return tree.getHash(addr);
+    }
+}
diff -ruN common/rewards-distribution/RewardsDistributor.sol common/rewards-distribution/RewardsDistributor.sol
--- common/rewards-distribution/RewardsDistributor.sol	2023-01-17 14:22:25.907789924 +0100
+++ common/rewards-distribution/RewardsDistributor.sol	2023-01-17 14:28:40.378226466 +0100
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 pragma solidity ^0.8.0;
 
-import "@rari-capital/solmate/src/utils/SafeTransferLib.sol";
+import "./dependencies/SafeTransferLib.sol"; // HARNESS
+import "./dependencies/MerkleProof.sol"; // HARNESS
 
-import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
 import "@openzeppelin/contracts/access/Ownable.sol";
 
 /// @title Morpho Rewards Distributor.
@@ -17,7 +17,6 @@
 
     ERC20 public immutable MORPHO;
     bytes32 public currRoot; // The merkle tree's root of the current rewards distribution.
-    bytes32 public prevRoot; // The merkle tree's root of the previous rewards distribution.
     mapping(address => uint256) public claimed; // The rewards already claimed. account -> amount.
 
     /// EVENTS ///
@@ -57,7 +56,6 @@
     /// @notice Updates the current merkle tree's root.
     /// @param _newRoot The new merkle tree's root.
     function updateRoot(bytes32 _newRoot) external onlyOwner {
-        prevRoot = currRoot;
         currRoot = _newRoot;
         emit RootUpdated(_newRoot);
     }
@@ -85,7 +83,7 @@
             _proof,
             keccak256(abi.encodePacked(_account, _claimable))
         );
-        if (candidateRoot != currRoot && candidateRoot != prevRoot) revert ProofInvalidOrExpired();
+        if (candidateRoot != currRoot) revert ProofInvalidOrExpired();
 
         uint256 alreadyClaimed = claimed[_account];
         if (_claimable <= alreadyClaimed) revert AlreadyClaimed();
diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 01:00:00.000000000 +0100
+++ .gitignore	2023-01-17 14:28:40.378226466 +0100
@@ -0,0 +1 @@
+*
